### 16.07 接口测试的测试理论

#### 软件测试的基本问题

在一个典型的测试项目中, 我们拿到一个软件系统, 要做测试. 这个系统有可能有文档, 也有可能没有. 有时候, 即使有文档也可能不完整或没有及时更新. 当拿到这个测试任务时, 我们首先要考虑以下基本问题:

1. 为什么要对这个系统进行测试, 你想在测试中发现什么? (测试目标问题)
2. 如何组织你的工作以实现你的目标? (测试策略问题)
3. 怎样知道系统在测试中最终是pass还是fail?(测试依据问题)
4. 如何对这个系统进行穷尽的测试?(测试的无穷性问题)
5. 不能做穷尽的测试, 那么要测多少才够? (测试完整性度量问题)

#### 软件测试的目标

软件测试可能的目标有很多, 以下是一些软件测试可能的目标:

* 找到重要的bug, 使他们得到修复
* 评估产品的质量
* 对是否发布产品的决策提供帮助
* 组织不成熟的产品被发布
* 对预测和控制产品的支持成本提供帮助
* 监测待测产品和其他产品的交互性
* 解释如何安全地使用产品
* 评估产品与实际需求的一致性
* 证明产品符合某个特定的标准(如国际标准, 国家标准等)
* 确保测试的过程符合问责制标准
* 减少产品可能引起的安全方面的诉讼风险
* 帮助客户提高产品的质量和可测试性
* 帮助客户改进他们的流程
* 作为第三方检测产品

注意, 我们在做实际项目时, 每个项目的目标都要自行根据实际情况分析, 并且在分析后, 排列各个目标的优先级. 这些目标和他们的优先级决定了我们的测试策略. 测试策略的意思就是指如何实现测试目标. 而接口测试, 正是测试策略的一种. 并不是任何项目都需要做接口测试, 当我们的项目有以下目标时, 往往考虑使用接口测试:

* 要快速验证功能的正确性并需要反复迭代
* 要验证基于软件即服务的架构开发的项目

前者，基本适用于现代的大多数项目，目前业内大多数项目采用迭代开发模式，并且往往每个迭代的时间都很紧张。测试过的功能又需要反复做回归测试。那么为了快速的回归测试， 我们往往会决定进行接口测试。同时，再辅以一些其他测试策略，比如手工测试或基于图形界面的自动化测试。具体来说，我们可以这样安排，在软件的第一个迭代期内，通过手工测试快速确保这个迭代的功能。同时挤出时间对其中部分功能做接口测试自动化的脚本编写。并在下个迭代中使用这些脚本做回归测试。然后每个迭代都增加新的自动化脚本并维护原有的脚本，逐步形成一个完整的测试用例集。

后者，当待测软件使用诸如SOA、微服务等理念或架构开发时，可能一个大项目分为几个小模块，其中有些模块的产物就是一些接口。那么对这些模块测试时，也会做接口测试。

另外，我们还要考虑什么情况下不用做接口测试：

* 当待测软件的主要功能均在客户端完成时，比如单机软件、单机游戏等。此时不涉及接口测试。
* 当待测软件用到的服务均由第三方提供时，比如测试一些第三方气象软件。气象数据的服务往往由气象台发布。此时即使做了接口测试也是与待测软件无关的。

值得注意的是，现在大多数软件都不是单机软件，因此大多数项目都需要做接口测试。但在软件测试行业中，确实存在一些小众领域，可能是用不到接口测试的。比如：门店软件测试、Pos机软件测试、车载软件测试、设计工具软件测试等等。在选择工作岗位时，我们需要注意，小众意味着跳槽困难。建议新人尽量做一些大众点的岗位。此外，也有一些软件虽然需要接口测试，但招专人去做，因此这些软件也会招专人去做不需要测接口的客户端软件测试岗位。这种模式在很多手机app项目里存在。

#### 接口测试的策略



#### 接口测试的依据

什么是测试的依据呢，测试的依据就是指我们来判断一个问题是不是bug的依据。同时，也指我们判断一个迭代的测试有没有通过的依据。

先说判断一个问题是不是bug的依据。作为测试人员，我们不仅仅是把所有问题都报上去就完事了。二是要对报上的问题做一些分析的。其中分析这个问题算不算bug，需不需要修复，就是最重要的分析了。在这个问题需要修复的前提下，再去分析bug的出现原因才是有意义的。

比如，在做接口测试时，当我们遇到接口返回值为200，是不是就表示这个接口调用成功了? 当接口返回一个表示错误的值，而没有给出错误的原因时，这个接口还正常吗？这都需要用测试依据的思维来分析，才能给出结论。

首先，第一个依据是接口文档。如果有详尽的接口文档，那么这些问题都可以迎刃而解。但是，实际项目中，可以说我们从未见过真正详尽的文档，即使有文档，往往也不全。因此，我们必须要具体问题具体分析。

第一个原则是分析问题对用户的严重程度。举个例子，有一个培训班的选课系统，在用户选择课程后，接口报错说失败，但接口返回值里没有给出失败原因。这算bug吗？选择失败的原因可能有：网络错误、课程人数已满、服务器内部出错等等。但用户不一定关心这个原因。用户可能只要知道选课成功还是失败就行了，那么在这种情况下，这个问题可以不算bug，或者把它认为是一个优先级很低的bug。而加入用户必须知道失败原因才能决定要不要再次选课，那这个原因缺失就是bug了。

第二个原则是看有谁关心这个问题。举个例子，有一个订单系统，新增数据时，只会返回success，而不返回这一条新增的数据的内容。这算bug吗？通常来说，没有这个返回数据，对功能并不影响，可以不算bug。但假如这个功能对性能测试人员来说很有必要的话，那也可以把它当做bug提出来要求开发把数据加到返回值里。同样，有些问题可能用户不关心，但别的模块的开发关心，又或者产品经理关心，这种情况下也可以判定为是一个需要修复的bug。

另外重要的原则还有：看有没有安全风险，比如会不会导致用户信息泄露或者出现安全漏洞。

在这就是判断一个迭代的测试有没有通过的依据。

对此, 我们要记住的是, 测试是为项目服务的,而不是反过来项目为测试服务. 所以测试人员通常不会说一个项目质量太差不能发布, 而是把当前质量状态下发布会产生的风险提示给项目相关人员. 具体风险可以是有多少严重程度为什么等级的bug, 有没有必须修复的严重问题仍未修复.

原则上讲, 如果有严重问题是不能发布的, 但如果拍板的经理或者整个团队都认为可以在这个风险下发布, 那么一般还是会发布的. 此种情况下, 我们可以重新评估这个问题的严重程度, 看是不是可以降低一下. 也就是说测试的依据并不是死板的, 而是随时根据项目实际情况可以调整的.

#### 接口测试无穷性和测试用例设计

软件测试是不可穷尽的. 对同一个软件, 可以设计无数的测试. 那么对于接口测试来说, 显而易见, 接口测试也是不可穷尽的. 对一个接口, 可能可以设计无数组传入参数, 那么如何来设计? 这里, 我们的原则是要用黑盒与白盒相结合, 也就是灰盒的方法来设计测试用例. 首先是测试用例设计依据:

* 接口文档优先
* 如果没有文档, 以抓包结果作为测试用例设计依据

通过阅读文档或抓包, 我们可以知道这个接口有哪些传入参数和返回参数. 但是对于参数的意义, 我们需要结合业务以及与开发、产品沟通来做了解

设计接口测试用例的一般步骤如下:

1. 设计传入参数和预期的返回参数
2. 使用发包工具或脚本调用接口, 如果调不通,需要跟开发沟通
3. 如果调通了,则作为一个接口调用的基础用例
4. 在基础用例上做扩充, 使用黑盒的等价类划分等方法设计传入参数. 形成单个接口的一组用例. 有时候我们要用到白盒的方法, 去阅读代码.比如当我们需要对接口做数据校验时, 需要读代码(或者问开发)才能知道要查数据库的哪个表
5. 在针对待测接口都设计好了基础用例的前提下, 组合各个接口,来设计多个接口串联调用的场景测试用例

这里要注意,有的项目可能不需要做场景测试,也有的项目可能不需要做单个接口测试,直接做场景测试即可. 这要根据实际项目来决定. 除了这些以外, 接口测试特有的测试场景也要注意:

1. 接口测试一定有返回值，而且这个返回值可能有多种错误代码，这些错误代码可以覆盖一下
2. 接口测试的鉴权机制是特有的，需要单独测试。常见的鉴权机制有：在请求头里包含token、在请求头里的cookie里包含token等
3. 在不同网络情况下的测试，根据实际情况决定是否需要做。比如用户会不会在弱网下调用这些接口。



### 16.10 接口测试框架设计

首先我们来讨论一下接口测试框架的组成部分, 请看下图, 这是一个简单的自动化测试框架, 在单机上运行时的过程

### 16.20 接口测试框架设计2



### 16.30 项目开始前的准备



### 16.35 代码的下载和提交



### 16.40 Rest请求客户端

需要写一个rest请求的客户端，这个类用于收发我们将要用到的http请求。

当我们需要做一些连续调用的请求时，需要使用requests的session功能。

```python
session = requests.session()

resp = session.post("http://wwww/", data={'username': "aaa", "password": "1111"})
print(resp.text)

resp = session.post("http://www", data={"xxx": "xxx"})
print(resp.text)
```

由于登录和登录后的请求都是由同一个requests session对象来发出，两个请求里带了同样的header信息，包括里面的cookie信息，因此可以模拟用户在浏览器上先登录再xxx的操作。

再优化一下，加入：

给一个网站加一个默认的URL地址前缀：

我们可以建一个类，自动给所有url加上前缀

```python
import requests, json

```



### 16.50 通过接口登录GitHub

### 16.60 封装一个 Get 请求

### 16.70 进一步思考 Get 请求的封装

### 16.80 封装更多类型的请求

### 16.90 在项目实战中提交代码

### 16.100 TUGithubAPI 项目的介绍的补充

### 16.110 接口封装层设计的改进

### 16.120 关键字层的封装

### 16.130 接口测试框架设计3-TUGithubAPITest 的介绍

### 16.140 针对单个接口的测试

### 16.150 通过fixture 做测试环境的切换

### 16.160 给环境切换加上参数化

### 16.170 响应结果的预处理

### 16.180 针对场景的测试

### 16.190 如何在实际项目中应用测试框架