接口测试基础

14.10 认识接口测试

14.20 网络协议

14.30 网络分层和数据

14.40 应用层和http协议

14.50 其他层次和协议

14.60 使用requests访问豆瓣

14.70 requests构建HTTP请求

### 14.80 requests中的响应

上一节里我们了解了怎样用 requests 库来构建和发送HTTP 请求， 这一节我们来了解下怎样解析服务器端给的响应。先回顾一下HTTP响应的包结构：

|   状态行    | 版本 状态码 短语， 比如 HTTP 1.1 404 NotFound |
| :---------: | :-------------------------------------------: |
| Header 头部 |               字段名： 字段值…                |
| Body 请求体 |          具体业务数据， 比如一个json          |

#### 在IDE 中打断点观察响应结构

这里来看一下调试器里显示的内容

r = {Response} 这个表示 r 是一个 Response 类的实例, Response 类是 requests 库里定义来表示响应的类

r._content 等以下划线开头的内部变量我们暂时不用管

r.connection 看上去存放了一些连接相关的内容, 我们一般也不用

==`r.content` 这个就是响应主体内容, 以字节 bytes 类型保存, 我们把它转换成字典或字符串后就是我们想要的**响应数据**==.

<u>r.cookies 这个保存了这个响应带的cookie, 一般也没什么用, 后面我们会用 requests 的会话来管理 cookie.</u>

r.elapsed 这个请求的响应时间.

r.status_code 这个就是HTTP 响应里的状态码, 非常重要, 常用于写断言

r.reason 这里会包含一个短语, 如果响应失败, 会告诉你失败原因

==`r.text` 响应数据转换成的文本==

r.url 这个响应来自于哪个url

#### 解析响应

例2: 解析一个响应

```python
import requests, json

r = requests.get('https://api.github.com/events')
print(r.content)

dict_json = json.loads(r.content)
print(dict_json)
```

在这个例子里, 我们用json 这个库解析了 github 给我们返回的响应数据.

通过打断点调试, 可以看到 dict_json 其实是一个列表, 列表元素是字典, 字典里包含了 github 的各种事件信息:

例3: 使用requests 库自带的 json 解析器解析响应

```python
import requests

r = requests.get('https://api.github.com/events')
print(r.json())
```

可以看到, 同样解析出了一个包含很多字典的列表. 一般建议用的是<u>例3的方式解析json数据, 比较方便. 当然有时候解析也会失败(比如服务器返回了一个格式错误的json), 那时就可以通过观察 `r.content` 和 `r.text` 等来分析原因.</u>



### 14.90 requests中的会话

之前的例子中，我们都是单独调用接口或解析响应，但在实际应用场景中，我们往往会需要连续调用一些接口。

比如：

1. 先登录
2. 再做一些操作
3. 最后登出

就像我们在浏览器中对网页做操作一样， requests 也可以模拟这些操作的步骤

在开始之前，我们简单了解下浏览器是怎样做到这些事情的, 为什么我们在浏览器里登录了某个网站后, 这个网站就知道我们后续的操作都是在这个刚刚登录的账号里做的呢?

#### cookies和session

这里有两个概念, 一个是cookies, 一个是session

Cookie 或者 Cookies 是Web 服务器**保存在用户浏览器**上的小文本文件. 它可以包含有关用户的信息, 比如用户名、甚至加密后的密码之类的信息. 这样, 当我们再次使用这个浏览器访问这个服务器时, 服务器可以直接读取这些信息, 而无需用户再次输入.

Session, 称为会话, 用户通常会在服务器提供的网页之间进行跳转来访问不同的页面, 服务器对一个用户创建一个session 对象, **存放在服务器端**, 这样服务器就知道这个用户是谁了. session 里也可以存放用户名等信息.

Session 一般是==会过期自动终止==的, 毕竟服务器端资源有限, 一段时间不操作, 很多网站就会自动删除你的session, 这时你再做操作, 网站会提示你重新登录. 而有些网站在提示你重新登录时, 页面上还会显示“欢迎, 某某某”这样的滋养, 因为这后面的用户名它很可能是存在了你的浏览器cookies 里, 所以你重新操作时, 网页还是知道你的用户名, 毕竟==cookies 是不会自动被删除的==, 顺带一提, <u>cookies 是保存在客户端, 所以我们是可以设置要不要保存cookies的</u>, 很多网站都设置了如果不保存cookies 将提示你无法使用该网站.

#### requests中的cookies

在 requests 中, 响应和请求里都有 cookies 功能.

如果某个响应中包含一些cookie, 你可以快速访问他们:

```python
>>> url = "http://example.com/some/cookie/setting/url"
>>> r = requests.get(url)
>>> r.cookies['example_cookie_name']
'example_cookie_value'
```

要想发送你的cookies到服务器, 可以使用 cookies 参数:

```python
>>> url = "http://httpbin.org/cookies"
>>> cookies = dict(cookies_are='working')
>>> r = requests.get(url, cookies=cookies)
>>> r.text
'{"cookies": {"cookies_are": "working"}}'
```

Cookie 的返回对象为 RequestsCookieJar, 它的行为和字典类似, 但接口更为完整, 适合跨域名跨路径使用.

你还可以把 Cookie Jar 传到 Requests 中:

```python
>>> jar = requests.cookies.RequestsCookieJar()
>>> jar.set('tasty_cookie', 'yum', domain='httpbin.org', path='/cookies')
>>> jar.set('gross_cookie', 'blench', domain='httpbin.org', path='/elsewhere')
>>> url = 'http://httpbin.org/cookies'
>>> r = requests.get(url, cookies=jar)
>>> r.text
'{"cookies": {"tasty_cookie": "yum"}}'
```

#### requests中的会话

在 requests 中, 也有回话的概念, 这里只是借用了session 这个名词, 但其实, 和服务端的session 并不同. requests 是模拟客户端的工具, 显然不可能用它来模拟服务端的会话. 但是, 我们也不想像上面的cookies 例子一样, 去手动在一系列请求和响应之间传递cookies

The Session object allows you to persist certain parameters across requests. It also persists cookies across all requests made from the Session instance, and will use urllib3’ s <u>connection pooling</u>. So if you’re making several requests to the same host, the underlying TCP connection will be reused, which can result in a significant performance increase.

A Session object has all the methods of the main Requests API.

requests 的 session 就帮助我们把这变成了自动的

例1: requests 中会话的例子

```python
import requests

s = requests.Session()
r = s.get('http://httpbin.org/cookies/set/sessioncookie/123456789')
r = s.get("http://httpbin.org/cookies")
print(r.text)
```

这个例子中:

第二行创建了一个requests 会话,

第三行使用 get 访问了一个网址, <u>**这个get 请求服务端创建了一个服务端的session 对象, 并且这个网址的作用是把服务端的 session 内容返回给用户.**</u>

第四行用户 get 了 另一个网址, 服务器返回了一个 `"sessioncookie": "123456789"` 的 json 数据. 这个数据恰恰是第三行的返回值, 这说明服务端正确地记住了我们.

==requests的session还有一部分没有写完==

15.0 测试执行器

15.10 初识测试执行器

15.20 测试执行器相关基础

15.30 使用unittest

15.40 使用pytest (1)

15.50 使用pytest (2)

### 16.07 接口测试的测试理论

#### 软件测试的基本问题

在一个典型的测试项目中, 我们拿到一个软件系统, 要做测试. 这个系统有可能有文档, 也有可能没有. 有时候, 即使有文档也可能不完整或没有及时更新. 当拿到这个测试任务时, 我们首先要考虑以下基本问题:

1. 为什么要对这个系统进行测试, 你想在测试中发现什么? (测试目标问题)
2. 如何组织你的工作以实现你的目标? (测试策略问题)
3. 怎样知道系统在测试中最终是pass还是fail?(测试依据问题)
4. 如何对这个系统进行穷尽的测试?(测试的无穷性问题)
5. 不能做穷尽的测试, 那么要测多少才够? (测试完整性度量问题)

#### 软件测试的目标

软件测试可能的目标有很多, 以下是一些软件测试可能的目标:

* 找到重要的bug, 使他们得到修复
* 评估产品的质量
* 对是否发布产品的决策提供帮助
* 组织不成熟的产品被发布
* 对预测和控制产品的支持成本提供帮助
* 监测待测产品和其他产品的交互性
* 解释如何安全地使用产品
* 评估产品与实际需求的一致性
* 证明产品符合某个特定的标准(如国际标准, 国家标准等)
* 确保测试的过程符合问责制标准
* 减少产品可能引起的安全方面的诉讼风险
* 帮助客户提高产品的质量和可测试性
* 帮助客户改进他们的流程
* 作为第三方检测产品

注意, 我们在做实际项目时, 每个项目的目标都要自行根据实际情况分析, 并且在分析后, 排列各个目标的优先级. 这些目标和他们的优先级决定了我们的测试策略. 测试策略的意思就是指如何实现测试目标. 而接口测试, 正是测试策略的一种. 并不是任何项目都需要做接口测试, 当我们的项目有以下目标时, 往往考虑使用接口测试:

* 要快速验证功能的正确性并需要反复迭代
* 要验证基于软件即服务的架构开发的项目

前者，基本适用于现代的大多数项目，目前业内大多数项目采用迭代开发模式，并且往往每个迭代的时间都很紧张。测试过的功能又需要反复做回归测试。那么为了快速的回归测试， 我们往往会决定进行接口测试。同时，再辅以一些其他测试策略，比如手工测试或基于图形界面的自动化测试。具体来说，我们可以这样安排，在软件的第一个迭代期内，通过手工测试快速确保这个迭代的功能。同时挤出时间对其中部分功能做接口测试自动化的脚本编写。并在下个迭代中使用这些脚本做回归测试。然后每个迭代都增加新的自动化脚本并维护原有的脚本，逐步形成一个完整的测试用例集。

后者，当待测软件使用诸如SOA、微服务等理念或架构开发时，可能一个大项目分为几个小模块，其中有些模块的产物就是一些接口。那么对这些模块测试时，也会做接口测试。

另外，我们还要考虑什么情况下不用做接口测试：

* 当待测软件的主要功能均在客户端完成时，比如单机软件、单机游戏等。此时不涉及接口测试。
* 当待测软件用到的服务均由第三方提供时，比如测试一些第三方气象软件。气象数据的服务往往由气象台发布。此时即使做了接口测试也是与待测软件无关的。

值得注意的是，现在大多数软件都不是单机软件，因此大多数项目都需要做接口测试。但在软件测试行业中，确实存在一些小众领域，可能是用不到接口测试的。比如：门店软件测试、Pos机软件测试、车载软件测试、设计工具软件测试等等。在选择工作岗位时，我们需要注意，小众意味着跳槽困难。建议新人尽量做一些大众点的岗位。此外，也有一些软件虽然需要接口测试，但招专人去做，因此这些软件也会招专人去做不需要测接口的客户端软件测试岗位。这种模式在很多手机app项目里存在。

#### 接口测试的策略

当我们基于项目的实际情况分析, 决定要做接口测试时, 就要考虑接口测试的策略, 也就是怎样做接口测试. 常见的做法有以下三种:

* 使用jmeter, postman, soapUI 等基于图形界面的工具去做
* 使用编程语言编写的自动化测试平台来做
* 使用编程语言编写接口测试框架加上脚本来做

这三种策略各有优势.

其中, 使用基于图形界面的工具去做, 好处主要是对测试人员要求低和上手速度快. 但缺点是可维护性差. 因为要求低, 如果选用这种策略, 可以尽量用较低的薪酬去招人, 压低项目成本.

而使用自动化测试平台来做则成本较高, 出成果较慢. 这种做法对测试人员的技术水平上最高的. 因此需要付出较高的薪酬. 当然, 如果在大厂, 不计成本去做的话, 使用自动化测试平台来做是很好的做法.

最后是使用接口测试框架加脚本来做.这种做法对测试人员的技术要求适中, 相信通过对本书的学习, 大家都可以达到这个要求. 这个做法的核心在于其使用的接口测试框架. 本书中给的框架就可以作为一个接口测试框架的模版, 根据实际情况, 大家对这个框架做修改, 来适应自己的项目即可.

选定接口测试的主要策略之后, 要做的事根据实际项目要求来决定具体的策略细节来. 比如, 笔者曾经做过一个广告接口的项目, 全部都是单个接口调用. 那么测试时,也只要对单个接口做调用即可.而另一个在线电影网站的项目中, 我们的接口不但要单独调用作测试, 还需要模拟用户场景做一些接口的串联调用.也就是用第一个接口的返回数据里的一些值作为第二个接口的输入参数.这样来模拟一些用户场景. 一个复杂的场景可能要调用十几个接口. 那么这里简单分一下:

* 对单个接口的测试
* 对多个接口库串联成的场景的测试

#### 接口测试的依据

什么是测试的依据呢，测试的依据就是指我们来判断一个问题是不是bug的依据。同时，也指我们判断一个迭代的测试有没有通过的依据。

先说判断一个问题是不是bug的依据。作为测试人员，我们不仅仅是把所有问题都报上去就完事了。二是要对报上的问题做一些分析的。其中分析这个问题算不算bug，需不需要修复，就是最重要的分析了。在这个问题需要修复的前提下，再去分析bug的出现原因才是有意义的。

比如，在做接口测试时，当我们遇到接口返回值为200，是不是就表示这个接口调用成功了? 当接口返回一个表示错误的值，而没有给出错误的原因时，这个接口还正常吗？这都需要用测试依据的思维来分析，才能给出结论。

首先，第一个依据是接口文档。如果有详尽的接口文档，那么这些问题都可以迎刃而解。但是，实际项目中，可以说我们从未见过真正详尽的文档，即使有文档，往往也不全。因此，我们必须要具体问题具体分析。

第一个原则是分析问题对用户的严重程度。举个例子，有一个培训班的选课系统，在用户选择课程后，接口报错说失败，但接口返回值里没有给出失败原因。这算bug吗？选择失败的原因可能有：网络错误、课程人数已满、服务器内部出错等等。但用户不一定关心这个原因。用户可能只要知道选课成功还是失败就行了，那么在这种情况下，这个问题可以不算bug，或者把它认为是一个优先级很低的bug。而加入用户必须知道失败原因才能决定要不要再次选课，那这个原因缺失就是bug了。

第二个原则是看有谁关心这个问题。举个例子，有一个订单系统，新增数据时，只会返回success，而不返回这一条新增的数据的内容。这算bug吗？通常来说，没有这个返回数据，对功能并不影响，可以不算bug。但假如这个功能对性能测试人员来说很有必要的话，那也可以把它当做bug提出来要求开发把数据加到返回值里。同样，有些问题可能用户不关心，但别的模块的开发关心，又或者产品经理关心，这种情况下也可以判定为是一个需要修复的bug。

另外重要的原则还有：看有没有安全风险，比如会不会导致用户信息泄露或者出现安全漏洞。

在这就是判断一个迭代的测试有没有通过的依据。

对此, 我们要记住的是, 测试是为项目服务的,而不是反过来项目为测试服务. 所以测试人员通常不会说一个项目质量太差不能发布, 而是把当前质量状态下发布会产生的风险提示给项目相关人员. 具体风险可以是有多少严重程度为什么等级的bug, 有没有必须修复的严重问题仍未修复.

原则上讲, 如果有严重问题是不能发布的, 但如果拍板的经理或者整个团队都认为可以在这个风险下发布, 那么一般还是会发布的. 此种情况下, 我们可以重新评估这个问题的严重程度, 看是不是可以降低一下. 也就是说测试的依据并不是死板的, 而是随时根据项目实际情况可以调整的.

#### 接口测试无穷性和测试用例设计

软件测试是不可穷尽的. 对同一个软件, 可以设计无数的测试. 那么对于接口测试来说, 显而易见, 接口测试也是不可穷尽的. 对一个接口, 可能可以设计无数组传入参数, 那么如何来设计? 这里, 我们的原则是要用黑盒与白盒相结合, 也就是灰盒的方法来设计测试用例. 首先是测试用例设计依据:

* 接口文档优先
* 如果没有文档, 以抓包结果作为测试用例设计依据

通过阅读文档或抓包, 我们可以知道这个接口有哪些传入参数和返回参数. 但是对于参数的意义, 我们需要结合业务以及与开发、产品沟通来做了解

设计接口测试用例的一般步骤如下:

1. 设计传入参数和预期的返回参数
2. 使用发包工具或脚本调用接口, 如果调不通,需要跟开发沟通
3. 如果调通了,则作为一个接口调用的基础用例
4. 在基础用例上做扩充, 使用黑盒的等价类划分等方法设计传入参数. 形成单个接口的一组用例. 有时候我们要用到白盒的方法, 去阅读代码.比如当我们需要对接口做数据校验时, 需要读代码(或者问开发)才能知道要查数据库的哪个表
5. 在针对待测接口都设计好了基础用例的前提下, 组合各个接口,来设计多个接口串联调用的场景测试用例

这里要注意,有的项目可能不需要做场景测试,也有的项目可能不需要做单个接口测试,直接做场景测试即可. 这要根据实际项目来决定. 除了这些以外, 接口测试特有的测试场景也要注意:

1. 接口测试一定有返回值，而且这个返回值可能有多种错误代码，这些错误代码可以覆盖一下
2. 接口测试的鉴权机制是特有的，需要单独测试。常见的鉴权机制有：在请求头里包含token、在请求头里的cookie里包含token等
3. 在不同网络情况下的测试，根据实际情况决定是否需要做。比如用户会不会在弱网下调用这些接口。

### 16.10 接口测试框架设计

首先我们来讨论一下接口测试框架的组成部分, 请看下图, 这是一个简单的自动化测试框架, 在单机上运行时的过程:

![](https://file.zsxq.com/3a6/d7/a6d7d21e6aaeeaf6e3b0c63ff5b8d1af6b24ca9aebd8859506a08e30c9c38856)

首先测试人员启动了测试执行器, 测试执行器调用了测试套件(测试套件指测试用例的集合), 然后按照测试用例中描述的业务逻辑, 使用测试驱动库(如selenium, requests等) 去操作待测软件, 并从待测软件中收集业务逻辑的执行结果. 将结果汇总之后, 生成测试报告.

这就是一个最简单的测试框架的设计思路. 我们把测试驱动库, 测试执行器以及测试套件们看作一个整体, 称为测试框架. 要设计一个测试框架, 就要对这些组件分别进行需求分析和选型. 需求分析指的是我们把我们想要在这个程序里包含的功能点罗列出来.选型则是根据这些需求, 选择我们实现这些需求的方法, 这些方法可能是自己写代码实现, 也可能是使用第三方库实现

下面分别对各个组件进行需求分析和选型:

#### 1. 测试执行器

需求分析:

1. 可以调用测试用例, 并汇总成报告
2. 对失败的测试用例, 可以给出失败的原因
3. 对单个测试用例, 可以有前置操作或后置操作, 也就是支持俗称的setup和teardown
4. 可以按照需要执行选定的部分测试用例, 比如, 执行所有属于冒烟测试的测试用例.
5. 安装简单

选型: pytest

#### 2. 测试驱动库

需求分析:

1. 能发 HTTP 协议的接口请求

选型: requests

#### 3. 测试数据管理

暂时不需要

选型: 暂无, 前期测试数据将保存在文本文件里, 后期会单独讲.

#### 4. 测试报告

需求分析:

1. 要打出XML 报告和 HTML 报告
2. XML 报告应该和junit 兼容

选型: pytest-html

综上, 这个接口测试框架将基于 python+requests+pytest 来实现

### 16.20 接口测试框架设计2

首先我们把这个项目划分为两个子项目: TUGithubAPI 和 TUGithubAPITest

为什么这样划分?

这里我借鉴了python的rf 测试框架的设计理念: 关键字和脚本.

<img src="https://file.zsxq.com/330/e8/30e84bc8fcd3c3404fae631dcbe04dcabaa9c4bb1ea16b771644985a98b20bee" style="zoom:67%;" />

一个网站的后台 HTTP 接口可能包括了很多很多方法,

第一步, 我们把它封装成一个python类库. 回顾前面的教程, 我们曾经使用很多Py的标准库和一些第三方库. 我们设计一个接口测试框架的时候, 目的是能调用这个网站提供的HTTP接口, 那么怎样调用呢? 自然而然地, 我们就想到, 可以把这些http接口封装成普通的py库.

这也是软件测试开发中的第一大核心方法: 封装

请牢记封装的概念:

封装可以把不好用的东西改成好用的.

封装可以把别人的东西改成自己的.

封装可以往别人现有的东西上加你想要的功能

封装可以改变程序的运行和调用方式, http接口可以封装成py接口, 反过来py接口也可以封装成http接口. 

我们的框架计划是把GitHub提供的http接口封装成py类库. 这个库名为TUGithubAPI.

当这个封装完成后, 就像使用普通py库一样, 我们可以以类名加方法名的形式来调用http接口. 假设有一个测试用例, 我们要登录github, 然后创建一个新的repo, 之后在这个repo里创建一个文件. 那么可能是这样的:

```python
def test_create_repo_and_upload_file():
    github = Github(xxx).login(username=xxx, password=xxx)
    repo = github.create_repo(xxx)
    result = repo.upload_file(xxx)
    assert result.success=True,xxxx
```

而这样的测试用例集合就会存放在另一个项目中: TUGithubAPITest

两个项目的关系是这样的:

<img src="https://file.zsxq.com/34f/ce/4fce112b17104ec24f9e0cf449894dba66f317287f28bc754d6aa071f68418a0" style="zoom:75%;" />

TUGithubAPI 是真正调用Github 提供的 HTTP 接口的库.

因此, 如果只有 TUGithubAPI, 也可以用来在Github上做一些操作. 后面, 我们的项目也会从这个子项目开始写起.

再回到 关键字 和 脚本 的概念上来.

当我们在 TUGithubAPI 中把待测软件提供的接口封装成py方法后, 这些py方法其实就是rf中关键字的概念. 而我们在TUGithubAPITest 中调用这些关键字, 组成一个又一个测试用例, 这就是rf中的测试脚本的概念.

<img src="https://file.zsxq.com/31c/ca/1cca44848f6d170c121cfaf079dfecc5baaaf8a25334e5d40558471390980652" style="zoom:75%;" />

所以我们这个框架里吸收借鉴了rf的关键字和脚本的理念, 但又没有真正去用rf做测试执行器. 上一小节中, 我们选型测试执行器的时候选择了pytest, 原因是 它用起来比rf简单. 而当你真正掌握这个测试框架的抽象思想之后, 你可以替换其他工具选型.

拓展: 自动化脚本并不是一定要用来做测试, 还可以用来做自动化部署, 自动化运维等. 事实上在运维领域里, 也有很多出色的自动化工具, 应用了自动化的思想, 比如 ansible.

### 16.30 项目开始前的准备

1. 预先装好一个趁手的编程IDE

2. 预先安装好Git

3. 理解我们项目使用的git 分支模型和项目管理方式

	首先是Git 分支模型：

	master分支：主分支，我们将在主分支上做release， 也就是发版本

	**release分支**：<u>存放即将要发布到主分支的代码</u>，进release分支的代码必须是经过测试且可用的。同一时间可以有多个release分支。但项目初期我们将只使用一个release分支。后期则会改为多个分支交替发布。

	**integration分支**：<u>集成分支。项目成员提交的代码在集成分支进行集成。</u>

	dev分支：个人开发分支，项目成员个人可以创建并使用的分支

	hotfix分支：用来快速修复bug的分支

	teach分支：本项目特有的教学分支，在项目第一阶段中，每一小节的教程代码都会创建一个教学分支，方便大家直接下载源码进行学习。

每个分支都从上一个里拉出来，然后最终合入回这个分支。 Master里会依次拉出各个版本的release分支。当人力充足时，甚至可以同时并行拉出多个release 分支。

其他分支都会消失，而master分支永远延续。（有些项目中release分支会独立维护下去）

本项目作为开源项目的特殊管理模式：

本项目的项目成员==需要fork我们的主项目到自己的个人账号下的仓库中，从integration 分支拉出dev分支，再通过发起pull request 来把自己开发的代码提交到主代码仓库的 integration 分支==。

<img src="https://file.zsxq.com/3c8/b6/c8b6f0bcbc0e00e02c3d3402d2221de2358a482f75ff25bcab91c56af7b7621f" style="zoom:75%;" />

<u>这里有个小问题：难道不应该是先合并到自己的Integration分支，然后再从自己的Integration分支发起PR到主代码仓库的Integration分支吗？</u>

为了让大家都能有练习的机会，到时候会根据项目活跃程度，来拉出不同数量的integration分支供大家练习。

### 16.35 代码的下载和提交

怎样把一个github仓库的代码下载到本地，并修改和提交？

1. 复制下载链接
2. 在本地执行git clone
3. 默认克隆的是master分支，使用git checkout 切换分支
4. 还可以用git fetch 来拉取新增的分支

### 16.40 Rest请求客户端

需要写一个rest请求的客户端，命名为RestClient, 这个类用于收发我们将要用到的http请求。

假如我们不用这个类，收发请求一般是直接用requests来做。

例1. requests 收发请求的示例：

```python
response = requests.post("http://httpbin.org/post", data={'a':"b"})
print(response.text)
```

但这样发送的请求之间没有关联，当我们需要做一些==连续调用的请求==，比如“先登录再把商品加入购物车”的时候，==需要使用requests的session功能==。

```python
session = requests.session()

# 这一行表示登录
resp = session.post("http://wwww/", data={'username': "aaa", "password": "1111"})
print(resp.text)

# 这一行表示将商品加入购物车
resp = session.post("http://www", data={"xxx": "xxx"})
print(resp.text)
```

**由于登录和登录后的请求都是由同一个requests session对象来发出，两个请求里带了同样的header信息，包括里面的cookie信息，因此可以模拟用户在浏览器上先登录再xxx的操作。**

一般来说使用session足够用了，但是我们可以再优化一下，加入：<u>给一个网站加一个默认的URL地址前缀</u> 这个功能

比如我们的测试都是针对 github.com 这个网站来做的，那么按脚本2的写法，我们每个请求里都要写一遍完整的url，这使代码显得有些冗余。因此我们可以建一个类，自动给所有url加上前缀

```python
import requests, json

class RestClient:
    
    def __init__(self, api_root_url):
        self.api_root_url = api_root_url
        self.session = requests.session()
        
    def get(self, url, **kwargs):
        return self.request(url, "get", **kwargs)
    
    def request(self, url, method_name, data=None, json=None, **kwargs):
        url = self.api_root_url + url
        if method_name == "get":
            return self.session.get(url, **kwargs)
        ...
```

这里，这个类加了一些方法， 包括：

1. init方法： 初始化这个类，初始化的时候需要输入 api_root_url, 也就是URL的前缀。另外在初始化时创建了`self.session` 用于保存requests 的session
2. get, post 等各种http方法， 用于让用户使用，但这里并没有真正实现这些方法。 因为这些方法都是在requests里有实现过，我们只要把参数传给requests就行了。这个传递我们写在request方法里，所以这里的HTTP方法都是调用requests方法。
3. request 方法： 真正调用`self.session`的各种方法，这里同样是把参数传下去，只是在传之前，给所有用户的输入的url加了一个前缀。前缀的值是用户在init方法里输入的。

例4：运行例3的类的代码：

```python
r = RestClient("http://httpbin.org")
x = r.post("/post", json={"a": "b"}
print(x.text)
```

这个例子介绍了怎样使用例3的 RestClient 向 http://httpbin.org/post 这个url post一个json对象，并打印了其返回值。所以我们看到了，一旦RestClient 这个类被实例化后，我们发请求不需要再输入完整的url，这将使未来的测试脚本代码得到重大简化。

### 16.50 通过接口登录GitHub

上一次，我们新建了 `core/rest_client.py`这个文件，并且可以使用其中的RestClient 类来收发http请求，这一小节，我们接着上次的rest 请求客户端，向其中增加登录GitHub的功能。

#### 通过API 登录 Github

官网介绍了 Github API支持的登录方式：

1. 用户名密码登录。最直接的方式，向服务端发送用户名密码来登录。此外，特定的一些api只能用这个方式登录。
2. token登录。最常用的方式，使用一个特殊字符串token来代替用户名密码，完成用户登录权限验证
3. SAML登录。企业级里常用的方式，可以和企业里其他用户认证方式结合。
4. two_factor 登录。要求二次鉴权的登录方式，比如手机验证码登录。

在本教程中，我们将实现用户名密码登录和token登录两种方式。

例1. 用户名密码登录和token登录的实现

```python
class RestClient:
    def __init__(self, api_root_url, username=None, password=None, token=None):
        self.api_root_url = api_root_url
        self.session = requests.session()
        if username and password:
            self.session.auth=(username, password)
        if token:
            self.session.headers['Authorization'] = "token {}".format(token)
```

这里, 通过修改 RestClient 类的初始化方法, 添加了三个参数, username, password和token. 当 username 和password 不为空时使用用户名密码登录, 向 requests session 中添加auth 信息. 当 token不为空时使用token 登录, 向requests session 的headers里的Authorization 字段添加token信息.

#### 目录结构

接下来我们要封装一个Github接口, 来看看登录效果. 在封装这个接口之前, 我们来看看目录结构:

<img src="https://file.zsxq.com/320/2e/202e6de32226baa91be49a63918ab2eedf1247695a46b78e8ca104ed11a2ad94" style="zoom:75%;" />



如图所示, 在TUGithubAPI 工程目录下, 我们新建了两个目录, 分别是API和core, core里存放核心的工具类RestClient, API里则会存放封装好的接口类. 而这两个目录外面还有一个`github.py`, 这个文件将作为总入口, 提供给这个代码库的用户使用.

今天我们要用的repos 接口是从github 文档的这里查到的:https://developer.github.com/v3/repos/

这里我们注意到有很多页面都挂在 Repositories下面. 这些都是我们后续要实现的. 现在我们的目录结构中, 只有`api/repositories/repos.py`, 后面就会有其他, 比如`branches.py`. 其他接口放在其他目录下. 

除了这些简单接口的封装, 存放在API 目录下外, 我们还会实现更业务化的连续操作, 比如通过调用若干个接口实现一个完整功能, 这种我们将来会在API目录同级别的地方建立domain目录, 来存放这类用户操作.

在这个小节中, 我们只是简单封装一下repos的一个接口, 来看看登录前后调用接口的区别, 下一小节才会正式封装这个接口.

#### 封装第一个Github接口

例2. `api/repositories/repos.py`

```python
from core.rest_client import RestClient

class Repos(RestClient):
    def __init__(self, api_root_url, **kwargs):
        super(Repos, self).__init__(api_root_url, **kwargs)
        
    def list_your_repos(self):
        return self.get("/user/repos")
```

例3. `github.py`

```python
from api.repositories.repos import Repos

class Github:
    def __init__(self, **kwargs):
        self.api_root_url = "http://api.github.com"
        self.repos = Repos(self.api_root_url, **kwargs)
        
        
if __name__ == "__main__":
    r = Github(token="xxxx")
    x = r.repos.list_your_repos()
    print(x.text)
    
    r = Github(username="xxxx", password="xxxx")
    x = r.repos.list_your_repos()
    print(x.text)
```

例2中, 我们又建立了一个新的类Repos, Repos是 RestClient 的一个子类

值得注意的是, 它的初始化方法有着和父类不一样的参数表(注意子类和父类的初始化方法可以接受不同的参数表):

```python
def __init__(self, api_root_url, **kwargs)
```

它接受了一个固定参数 api_root_url, 和一个关键字参数 `**kwargs`

固定参数大家很好理解, 而关键字参数的意思是, 可以传入任意的键值对作为参数. 当然, 观察父类的代码我们就知道, 这里虽然可以传任意的关键字参数, 但只有 username, password, token 这三个参数会被处理. 这里的关键是: ==Repos 作为一个子类, 它不需要知道哪些参数会被处理以及会被怎样处理, 它就直接在自己的初始化方法里调用了父类的初始化方法, 不论用户传入了几个参数, 它都原封不动传给它的父类==.

```python
super(Repos, self).__init__(api_root_url, **kwargs)
```

这里的super就是表示父类, 这一行调用父类的`__init__`方法.

初始化完成后, 自然就可以在子类中使用self来直接使用父类的方法了, 比如get 方法.

```python
def list_your_repos(self):
    return self.get("/user/repos")
```

我们先通过浏览器访问`https://api.github.com/user/repos`, 得到一个401 Unauthorized.

这是因为, 我们通过浏览器访问时, 没有登录. 系统返回401未授权的访问, 并要求我们登录.

而运行例3的代码, 则会得到你登录的用户的所有repos信息. 

例3的代码中, 我们使用了组合模式来做封装. 

首先我们建立一个Github类, Github类负责接收用户输入的用户名、密码、token、url等参数, 并且在其成员变量中新建repos 类的实例. 而repos 类又继承自 RestClient 类. 所以, 相当于, 一个Github 类实例里有多个RestClient的子类的实例. 类比于一辆车上有前轮后轮, 而前轮后轮都是继承自轮子这个类.

### 16.60 封装一个 Get 请求

上一小节中，我们初步封装了一个列出所有repos的接口，这次进一步完善这个接口的封装。

这个接口的调用方式是： GET /users/repos

这里的GET 表示使用http的get方法来调用这个接口，后面的/user/repos 则表示接口的URL

这个接口用来列出当前用户能读、写或管理的repos

背景补充：

在 github 上，一个用户对一个repo有三种权限：

read， write， admin

Github的文档中分三列来介绍这个接口的参数：

Name为参数名，文档显示这个接口接受5个参数。

Type 为参数的数据类型，在这个接口中，全部都是字符串 string

Description 为参数的业务描述，其中还会给出默认值等信息。

| Name        | Type   | Description                                                  |
| ----------- | ------ | ------------------------------------------------------------ |
| visibility  | string | Can be one of all, public, or private. Default: all          |
| affiliation | string | Comma-separated list of values. Can include:<br>* owner: Repositories that are owned by the authenticated user<br>* collaborator: Repositories that the user has been added to as a collaborator.<br>*organization_member: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on.<br>Default: owner, collaborator, organization_member |
| type        | string | Can be one of all, owner, public, private, member. Default: all<br>Will cause a 422 error if used in the same requests as visibility or affiliation. |
| sort        | string | Can be one of the created, updated, pushed, full_name. Default: full_name |
| direction   | string | Can be one of asc or desc. Default: asc when using full_name, otherwise desc |

visibility: Github的代码仓库分为public repo 和 private repo，前者就是公开的，后者是私有的。私有的需要付费才能创建。这个参数接受all, public, private 三种值， 默认为all

affiliation：这是用于表示用户在repo中的身份角色。比如owner，就是repo的管理员，如果你自己创建一个repo， 你就是其owner。此外还有 collaborator和organization_member 两种身份

collaborator 是repo 的 owner 在设置里设的。 organization member 则是organization 的管理员在设置中可以设的。

值得注意的是，这个参数的默认值是owner, collaborator, organization_member 也就是你是三种角色的任何一种都可以。这个参数接受的是由逗号隔开的一组值。这样，用户输入参数时可以灵活选择。

type：可以是all, owner, public, private, member 中的任意一个， 默认值为all。这里，文档上特意指出了type 和affiliation 如果在同一个请求里一起用的话，会的到一个422错误。 大家需要明确一个概念，任何请求都可以得到任何返回值，具体得到什么，都是程序员在代码里设置的。所以这里可以看到github的程序员虽然设置了type和affiliation两个过滤repo的参数，但是，他们并不允许用户同时使用这两个参数。

sort： 结果的排序方式。 可以是created, updated, pushed 或者full_name. 默认是full_name。 这个参数是用来给返回值排序的。根据repo的创建时间，更新时间，最后提交代码时间或者名称排序。

direction: 用来确定排序顺序，可以是asc 或 desc 升序或降序。这个参数的默认值也很有意思，当sort 使用full_name 时，direction 默认是升序，否则默认是降序。

我们可以看到，定义一个接口可以是很灵活的，参数之间可以互相独立，也可以有依赖关系，甚至可以规定不能同时使用的参数。

例1. GET /user/repos 接口的封装代码实现：

```python
def list_your_repos(self, visibility=None, affiliation=None, type=None, sort=None, direction=None):
    params = {"visibility": visibility, "affiliation": affiliation, "type": type, "direction": direction}
    return self.get("/user/repos", params=params)
```

第三行的get会调用到父类RestClient里定义的get方法：

```python
def get(self, url, **kwargs):
    return self.request(url, "get", **kwargs)
```

这个地方会调用 RestClient 的 request 方法

```python
if method == "get":
    return self.session.get(url, **kwargs)
```

从而最终走到 requests session 的get 方法.

最后我们来测试一下封装好的方法. 测试代码放在`github.py`里.

```python
r = Github(token="xxxx")
x = r.repos.list_your_repos()
print(x.text)


r = Github(token="xxxx")
x = r.repos.list_your_repos(visibility="private")
print(x.text)


```

第一行为默认调用, 没有传参数, 全部使用默认值. 在我们的封装里直接传了None, 但Github那边仍旧是按照没有传这个参数来处理的, 到底是不是这样处理, 这是由代码决定的, 所以如果大家测试其他的网站, 不可以生搬硬套传个None做默认值, 要确定你们的待测软件对参数如何处理.

第二行是传了visibility=private时的返回值,



### 16.70 进一步思考 Get 请求的封装

上一小节中，封装了list_your_repo, 这一小节我们继续改造这个封装，使其更加完善。

首先我们回归一下上次的代码：

例1： GET /user/repos 接口的封装的代码实现：

```python
def list_your_repos(self,visibility=None,affiliation=None,
                    type=None,sort=None,direction=None):
    params = {"visibility": visibility,
              "affiliation": affiliation,
              "type": type,
              "sort": sort,
              "direction": direction}
    return self.get("/user/repos", params=params)
```

这段代码的问题是方法的参数非常长。

这里我们把它简化一下：

例2： GET /user/repos 接口的封装的代码简化：

```python
def list_your_repos(self, **kwargs):
    return self.get("/user/repos", **kwargs)
```

这样，简化成了两行代码，直接让调用这个库的用户自己输入参数，对应的调用的地方也会做修改：

例3：对修改后的list_your_repos 的调用

```python
r = Github(token="xxxx")
data = {"direction": "desc"}
x = r.repos.list_your_repos(params=data)
print(x.text)
```

这里跟上一节的例子的区别就是增加了第二行data，然后在调用list_your_repos时直接把这个data以关键字参数的形式`params=data`传了过去

按照例2的思路，我们就可以对github的接口做更加简洁的封装。事实上，这里的封装将只包含三个信息：

1. 接口的HTTP方法名称，在return语句里，用`self.xxx`的xxx来表示
2. 接口的URL
3. 我们起的方法名

最后在文档里补上官方文档的链接。告诉用户到哪里去查这个方法的详细用法。

而关于参数和返回值的文档，没有写，因为`**kwargs`这个参数和默认的返回值，我们这里所有基础封装方法都是一样的。只有当我们封装的方法出现了`**kwargs`以外的参数和特殊的返回值时才写。

总结一下这个项目中基础封装的原则：

1. 我们在这个项目中封装的github接口，每个方法的代码里需要包含url和http方法名两个信息。
2. 每个方法的文档里需要包含指向github 官方文档的链接
3. 每个方法的参数中质保函必要信息，并且尽量少

例5：对 GET /users/:username/repos 的封装

```python
def list_user_repos(self, username, **kwargs):
    """
    https://developer.github.com/v3/repos/#list-user-repositories
    :param username: username
    """
    return self.get("/users/{}/repos".format(username), **kwargs)
```

这是一个带参数的基础封装的例子。因为username会作为url的一部分，所以给他单独加了个参数。这个方法和例1的封装方法基本相同，区别是例5是查一个用户名下的repo信息，例1是查当前登录用户的repo信息。

例6.调用例5的代码：

```python
r = Github(token="xxxx")
data = {"direction": "desc"}
x = r.repos.list_your_repos("zhangting85", params=data)
print(x.text)
```



### 16.80 封装更多类型的请求

今天我们继续封装 repository 库里的其他接口。

这里会用到这些接口文档：

新建repo： https://developer.github.com/v3/repos/#create

获取repo

编辑repo：

可以从文档中看到，新建repo是用的HTTP的post方法，获取repo是用的get方法，编辑repo则使用patch方法。

这里我们可以简单地认为，在技术上，这些http方法的区别不大。都是把消息封装成HTTP数据包后发过去。我们看一下实现：

例1. 今天这3个接口的实现：

```python
def create_user_repo(self, **kwargs):
    return self.post("/user/repos", **kwargs)

def create_organization_repo(self,org, **kwargs):
    return self.post("/orgs/{}/repos", **kwargs)

def get

def edit_repo(self, owner, repo, **kwargs)
```

新建repo的接口写了两个方法：

create_user_repo 是在github用户名下新建repo

create_organization_repo 是在github的机构名下新建repo

这里的用户或机构，又叫做owner，也就是repo的拥有者的意思。

get_repo方法上，要求输入 owner和repo名称。这是获取一个repo必须要输入的值，而这个方法后面的`**kwargs`现在是不需要的，但是现在留着也没事。

edit_repo 则是编辑一个repo时用的，也需要输入owner和repo的名字

例2：调用这些接口的例子

```python
r = Github(token="xxxx")
username = "zhangting85"
orgname = "xxxx"

# case 1
data = {
    "name": "hello-world",
    "description": "This is your first repository",
    "homepage": "https://github.com",
    "private": False,
    "has_issues": True,
    "has_projects": True,
    "has_wiki": True
}
x = r.repos.create_user_repo(json=data)
print(x.status_code)
assert x.status_code == 201

# case 2
x = r.repos.create_orgnaization_repo(org=orgname, json=data)
print(x.status_code)
assert x.status_code == 201


```

首先，使用token登录Github



case 1

调用创建repo的方法。注意这里并不需要输入用户名。

Github会自动根据token找到我们的用户名。

值得一提的是，==我们把这个repo的详细信息用 json=字典 的写法传下去，最终json=xxx是由requests库提供的。也就是说，在调用post方法时，我们不需要显示地把数据转换成json数据类型，只要用 json=字典 这样的就行了==

(json数据类型可以理解成把python的字典转换成一种特殊格式的字符串。主要的特殊性在于json一定要用双引号，而不是单引号)

例3： 给patch 方法加一个自动的json类型转换

```python
if method_name == "patch":
    if json:
        data = json_parser.dumps(json)
    return self.session.patch(url, data, **kwargs)
```





### 16.90 在项目实战中提交代码

以下步骤以TUGithubAPI 项目为例：

1. 接任务
	1. 打开TUGithubAPI 项目首页
	2. 点击下图链接进入projects
	3. 点击下图链接进入看板
	4. 如下图所示，看板上有三列：
		* 需要做的需求：这是所有待完成的任务
		* 进行中：这一列是所有正在做的任务
		* 完成： 这一列是已完成的任务
	5. 首先
	6. 点击
	7. 红框4
	8. 点击红框2
	9. 最后，在
2. 下载代码并修改和提交
	1. fork 你要提交代码的仓库到你的GitHub
	
	2. 在fork 出来的仓库中, 从integration_1 分支上拉出一个新的分支, 命名为 feature_xxx 这里xxx你自己可以定义.
	
	   这里integration_1 表示这是 release_1 的集成分支. 当项目进入release 2, 这里自然也改用 release_2.
	
	   feature_xxx 表示开发分支. 每个人都可以有自己的开发分支.
	
	   当我代码写完之后并提交到我fork下来的仓库里之后, 点击这个按钮进入 pull request 建立页面:
	
	   <img src="https://file.zsxq.com/337/90/37900f8be4ab87178cf0ced7f59ee0a2755e20f2ee4b080d20502e79a15c4b20" style="zoom:75%;" />
	
	   红框1 中有四个下拉框, 依次是目标仓库.
	
	3. 更新fork 出来的代码仓库
	
	  当我们把社群的仓库fork到自己的GitHub账号下后, 社群的仓库里的代码改动还在继续.如果我们想要把社群里的新改动拉到自己账号里的仓库中, 应该怎么做?
	
	  1. 点这里新建 PR
	
	  也就是说, 从社群的仓库发一个PR 到你自己的仓库上
	
	  最后点击 merge pull request, 就会把代码从社群的仓库的指定分支上同步到自己账号的仓库中的指定分支上了.

### 16.100 TUGithubAPI 项目的介绍的补充

从这里可以看到所有需求列表：

这个是接口封装的看板：

当第一列要做的需求被接完之后，我会继续更新新的需求。

后续也可能新增其他任务类型的看板。

我们的项目实战一共分4种任务。

1. 接口封装，也就是我们16.60到16.80为止介绍的任务类型，完成了把HTTP接口封装成python接口的。第一个看板就是针对这类任务的。
2. 关键字封装，把一个或多个接口组合起来，实现某种业务功能
3. 测试脚本封装，把多个关键字组合起来，实现某种测试用例。此类型任务在TUGithubAPITest项目中。
4. 框架完善任务，进一步完善测试框架。此类型任务在TUGithubAPITest项目中。

TUGithubAPI 和 TUGithubAPITest 两个项目加起来为一个完整的接口测试框架和脚本。

这两个项目的作用：

假设你去面试，面试官和你的交流如下：

问：给你一个网站接口项目要你测，你怎么测？

答：我搭建一套测试框架，使用python来进行自动化接口测试

问：你的框架怎么设计，有哪些模块？

答：分成接口封装、关键字封装、测试用例等模块。用python把HTTP接口封装成python接口，然后把这些几口组装成一个个的关键字，再把关键字组装成测试用例。最后用测试执行器来运行这些脚本，并生成报告。具体的选型为 python+requests+pytest

问：那你介绍下你以前做过的项目里是怎么做这些模块的？

答：这里就可以把你做过的任何项目套用我们现在这个项目实战的项目的皮，然后利用你在项目实战中学到的经验，展示你的python自动化测试技能给面试官看。

这里，我们主要是构建，从一套HTTP接口，到封装成python接口，再到包装成关键字，组成测试用例，这一整个流程的原理。通过在项目实战中提交和阅读代码，来提高自己的代码熟练程度。

### 16.110 接口封装层设计的改进

首先我们来看一个读者提问，关于init方法里多余的语句。

例1： init方法里多余的语句

```python
class Repos(RestClient):
    def __init__(self, api_root_url, **kwargs):
        super(Repos, self).__init__(api_root_url, **kwargs)
```

其中`super(Repos, self).__init__(api_root_url, **kwargs)` 这一行是不需要的。这整个初始化方法即使整个删掉也不影响我们之前的代码运行。

原因是：

如果不写Repos类的初始化方法，就会默认使用父类的初始化方法。这样的话，仍然可以完成初始化。

<u>那么什么情况下我们需要这句话？</u>

**当我们要继续扩展这个初始化方法，并保留父类初始化方法功能的时候。**

例2： 越来越大的`github.py`

```python
from api.repositories.repos import Repos
from api.repositories.traffic import Traffic
from api.issues.issues import Issues

class Github:
    def __init__(self, **kwargs):
        self.api_root_url = "http://api.github.com"
        self.repos = Repos(self.api_root_url, **kwargs)
        self.issues = Issues(self.api_root_url, **kwargs)
        self.traffic = Traffic(self.api_root_url, **kwargs)
```

在这个代码片段中，我们看到了init方法下的内容越来越多。

每一次有新的类创建的时候，这里都会加上一个`self.xxxx =  xxxx`

实际上我们有几十个类会创建，那么最后这里就会有几十个`self.xxx`，这将导致github类的使用变得困难。

对此，项目做了如下设想：

即代码组织完全按照官方文档的结构。

我们在之前已经按照官方文档的结构创建了目录和文件。（参照github上创建的需求列表和teach_006分支的代码。teach_006分支仅仅创建了一些文件和目录，因为过于简单，并没有单独写教程）

介绍下teach_006里创建的文件目录的含义

举例：

repos的文档存放在：

branches的文档存放在：

这两个地址我们把它称为“文档URL”

从文档URL上看，他们都是 repos 下面的

那么对应的就会在 api/repositories/ 文件夹下，有两个类： `repos.py` 和 `branches.py`

这两个类的类名对应于“文档URL”结尾的最后一个单词，也就是 repos 和 branches

而他们所存放的那个目录名 api/repositories/ 其中的 repositories 是取自 Repos 的 文档 URL 的大标题

这里，我们也可以从文档URL 上看出来， repos 和 branches 并不是同一级别或是层次的。我们可以这样理解，branches 是 repos 下面的组件。

那么，因为branches 是 repos 下面一级的，所以我们在调用 branches 类的时候希望是这样的：

`github.repos.branches.xxx` 而不是 `github.branches.xxxx`

为了实现这个功能，请看例3

例3：增加了几个类的repos初始化方法

```python
class Repos(RestClient):
    def __init__(self, api_root_url, **kwargs):
        super(Repos, self).__init__(api_root_url, **kwargs)
    self.releases = Releases(self.api_root_url, **kwargs)
    
```

例4：修改过的`github.py`里的测试方法

```python
if __name__ == '__main__':
    r = Github(token="xxxx")
    username = "zhangting85"
    orgname = "TestUpCommunity"
    reponame = "simpleWebTest"
    
    # case 1
    x = r.repos.traffic.list_clones(username, reponame)
    assert x.status_code == 200
    print(x.text)
```

例3 我们把这些附属类直接在 Repos 的 init 里新建，这就解决了例1中提出来的是否需要init方法。当然这些附属类就可以不写init方法了

例4 我们调用了`repos.traffic` 下面的 list_clone 方法， 让github 告诉我们某个用户名下的某个repo 被 clone 过几次

同时，我们的list_clones方法的实现有点问题。但，不要紧，这些第一层的代码到底正不正确，现在并不重要

任务1. 修改例4的代码，



### 16.120 关键字层的封装



### 16.130 接口测试框架设计3-TUGithubAPITest 的介绍



### 16.140 针对单个接口的测试



### 16.150 通过fixture 做测试环境的切换



### 16.160 给环境切换加上参数化



### 16.170 响应结果的预处理



### 16.180 针对场景的测试



### 16.190 如何在实际项目中应用测试框架