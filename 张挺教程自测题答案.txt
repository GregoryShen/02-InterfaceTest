14.10 认识接口测试
1. 手工测试和接口测试的简略结构是怎样的？
略

2. 接口测试的目标是什么？
接口测试的目标通常就是测试服务端程序

3. UI和GUI是什么？有什么区别？
UI是 User Interface, 用户接口
GUI 是 Graphical User Interface, 图形化用户接口
区别是UI泛指各种给用户提供的界面，比如Linux操作系统中的命令行界面也是一种 UI
而 GUI 指图形化界面

4. 封包和解包的过程是怎样的？
当我们操作 UI 时，客户端程序会把我们想要发送给服务端程序的指令封装成数据包，会封装成什么
类型的包取决于数据在网络的哪一层封装。 当服务端把数据处理完毕或指令执行完毕后，服务端会把
要给用户看的数据也封成包发送回客户端。客户端再把包解开给用户看里面的数据，这就是封包和解包
的过程

5. 图形界面测试和接口测试的测试对象有什么不同？
图形界面测试的测试对象是整个程序，也就是我们把客户端程序加上服务端程序视为一个黑盒。
接口测试的测试对象是服务端程序，也就是说我们把服务端程序视为一个黑盒，用工具或脚本
去模拟客户端程序的工作，包括封包、发送、解包等。

6. 什么是 Mock？
用代码去模拟某部分我们不想测的东西的做法，我们通常称为 Mock


14.20 网络协议
1. 网络协议是什么?
网络协议定义了计算机之间通信的方式

2. 协议的核心是什么?
询问和回答的交流方式就是协议的核心, 也就是请求和响应

3. 什么是协议?
协议定义了通信实体间交换的报文格式和次序以及发送和接收报文的方式及处理动作


14.30 网络分层和数据
1. 为什么网络是要分层的?


2. 网络分层方法有哪些?


3. 分层和接口测试的关系?


4. 更广义的接口测试是什么?


14.40 应用层和http协议
1. 应用层是用来干嘛的? 有哪些常见的协议?
2. 应用层的网络应用程序是怎样工作的?
3. HTTP 协议里是怎样封报文和解报文的?
4. HTTP 协议里请求和响应的格式分别是什么?
5. 301, 400, 404, 500 分别代表什么含义?


14.90 requests 中的会话

1. cookie和session的定义？以及他们的区别
cookie 是 Web 服务器保存在用户浏览器上的小文本文件, 它可以包含用户的信息, 比如用户名、加密后的密码等信息.
当我们再次使用这个浏览器访问这个服务器时, 服务器可以直接读取这些信息, 而无需用户再次输入.
session 称为会话, 用户通常会在服务器提供的网页之间进行跳转来访问不同的页面, 服务器对一个用户创建一个 session 对象
存放在服务器端, 这样服务器就知道这个用户是谁了.
区别:
cookie 是存储在客户端, 不会被自动删除
session 是存储在服务端, 在服务端的文件或数据库中都可以
一般来说 session 的验证需要 cookie 带一个字段来表示这个用户是哪一个 session, 所以当客户端禁用 cookie 时, session 将失效.

2. 如果响应中含有cookies，如何读取？给出示例代码 url="http://example.com/some/cookie/setting/url", cookie的name是example_cookie_name
3. 如果想在请求中添加cookies，如何操作？ url=http://httpbin.org/cookies
4. 如何把RequestCookieJar 添加到请求中？ 给出示例代码 url=http://httpbin.org/cookies
5. 如何在requests中使用会话？给出示例代码？ 也就是如何证明session的功能？
   就是可以在不同请求中确认服务器记住了我们的cookie






16.07 接口测试的测试理论

1. 什么情况下需要考虑使用接口测试？
1）要快速验证功能的正确性并且需要反复迭代
2）要验证基于软件即服务的架构开发的项目

2. 在快速迭代开发的项目过程中如何落地接口测试？
1） 在软件的第一个迭代期内，通过手工测试快速确保这个迭代的功能。
    同时挤出时间对其中部分功能做接口测试自动化的脚本编写。
2） 在下个迭代中使用这些脚本做回归测试
3） 每个迭代都增加新的自动化脚本并维护原有的脚本，逐步形成一个完整的测试用例集。

3. 什么情况下不用做接口测试？
1） 当待测软件的主要功能均在客户端完成时，比如单机软件、单机游戏等。此时不涉及接口测试。
2） 当待测软件用到的服务均由第三方提供时，比如测试一些第三方气象软件。气象数据的服务往往由气象台发布。
    此时即使做了接口测试也是与待测软件无关的。

4. 接口测试的策略？ 具体的两类策略细节？
策略：使用编程语言编写接口测试框架加上脚本。
细节：对单个接口测试；多个接口串联成场景测试

5. 判断一个问题是不是bug的依据有哪些?
1) 接口文档
2) 根据测试依据的思维具体问题具体分析, 具体的原则有
    1) 分析问题对用户的严重程度
    2) 看有谁关心这个问题
    3) 有没有安全风险

6. 判断一个迭代的测试有没有通过的依据?
测试是为项目服务的,而不是反过来项目为测试服务. 所以测试人员通常不会说一个项目质量太差不能发布, 
而是把当前质量状态下发布会产生的风险提示给项目相关人员. 
具体风险可以是有多少严重程度为什么等级的bug, 有没有必须修复的严重问题仍未修复.
原则上讲, 如果有严重问题是不能发布的, 但如果拍板的经理或者整个团队都认为可以在这个风险下发布, 
那么一般还是会发布的. 此种情况下, 我们可以重新评估这个问题的严重程度, 看是不是可以降低一下. 
也就是说测试的依据并不是死板的, 而是随时根据项目实际情况可以调整的.
----
ps 这么写我觉得还是不知道迭代通过的依据是什么

07. 如何对这个系统进行穷尽的测试?
软件测试是不可穷尽的, 对同一个软件, 可以设计无数的测试; 显而易见, 接口测试也是不可穷尽的, 对
一个接口可能可以设计无数组传入参数, 所以测试是不可穷尽的.

08. 不能做穷尽的测试, 那么要测多少才够?
这个问的是测试完整性度量的问题, 不知道怎么回答.


09. 接口测试测试用例的设计原则?
黑盒与白盒相结合, 也就是灰盒的方法来设计测试用例.

10. 接口测试测试用例的设计依据?
1) 接口文档优先
2) 如果没有文档, 以抓包结果作为测试用例设计依据
通过阅读文档或抓包, 我们可以知道这个接口有哪些传入参数和返回参数. 但是对于参数的意义, 我们还是
需要结合业务以及与开发、产品人员沟通来做了解.

11. 设计接口测试用例的一般步骤?
1) 设计传入参数和预期的返回参数
2) 使用发包工具或脚本调用接口, 如果调不通, 需要去跟开发沟通
3) 如果调通了, 则作为一个接口调用的基础用例
4) 在基础用例上做扩充, 使用黑盒的等价类划分等方法设计传入参数. 形成单个接口的一组用例.
   有时候需要用到白盒的方法去阅读代码. 比如当我们需要对接口做数据库校验时, 需要读代码(或者问开发)
   才能知道要查数据库的哪个表
5) 在针对待测接口都设计好了基础用例的前提下, 组合各个接口, 来设计多个接口串联调用的场景测试用例
有的项目不需要做场景测试, 也有可能不需要做单个接口测试, 直接做场景测试, 这要根据实际项目来决定 

12. 接口测试特有的测试场景?
1. 接口测试的返回值可能有多种错误代码, 这些错误代码可以覆盖一下
2. 鉴权机制需要单独测试, 常见的鉴权机制有: 在请求头里包含token, 在请求头里的cookie里包含token
3. 在不通网络状况下测试,比如弱网环境下.


16.10 接口测试框架设计
1. 描述一个自动化测试框架在单机上运行时的过程
首先启动测试执行器，测试执行器调用测试套件（测试套件指测试用例的集合），然后按照测试用例中
描述的业务逻辑，使用测试驱动库（如selenium，requests等）去操作待测软件，并从待测软件中收集业务
逻辑的执行结果，将结果汇总后，生成测试报告。

2. 在上述图示中圈出测试框架
我们把测试驱动库，测试执行器以及测试套件们看做一个整体，称为测试框架


16.20 接口测试框架设计2
1. TUGithubAPI和TUGithubAPITest分别是用来做什么的，二者的关系请画图说明
TUGithubAPI是把Github提供的HTTP接口封装成Python类库
TUGithubAPITest是把测试用例集合到一起

2. 解释关键字和脚本的概念
关键字就是把待测软件提供的接口封装成python方法，这些python方法就是关键字
调用关键字组成测试用例，就是测试脚本


16.30 项目开始前的准备
1. 解释master、release、integration、dev、hotfix、teach分支的含义
master分支：主分支。我们将在主分支上做release，也就是发版本。
release分支：存放即将要发布到主分支的代码，进release分支的代码必须是经过测试且可用的。
integration分支：集成分支。项目成员提交的代码在集成分支进行集成。
dev分支：个人开发分支，项目成员个人可以创建并使用的分支。
hotfix分支：用来快速修复bug的分支。
teach分支：本项目特有的教学分支，在项目第一阶段中，每一小节的教程代码都会创建一个教学分支，方便
大家直接下载源代码进行学习。这些分支的代码基本在创建完毕后就固定下来了。

2. 本项目作为开源项目的管理模式
本项目中，项目成员需要 fork 我们的主项目到自己的个人账号下的仓库中，从integration 分支拉出dev 
分支，再通过发起 pull request 来把自己开发的代码提交到主代码仓库的 integration分支。


16.120 关键字层的封装
1. 什么是关键字?
1) 就是一个按照一定格式封装好的 python 方法. 由于我们把这一层的关键字都按同样的格式
封装, 我们在测试用例中调用关键字时就可以按照同行的方式来调用.
2) 一个关键字应该具有一定的业务意义. 关键字例可以使用其他的关键字.
3) 最终我们用来组成测试用例的关键字一定是有比较明确的业务意义, 这样测试用例的可读性
通过关键字来保证

2. 封装关键字 create_repo, 包含在当前用户下创建repo和在某个组织下创建repo两个接口
   并指出该关键字存放的路径
路径: opreations/repo.py

from core.base import CommonItem

def create_repo(github, name, org=None, description=None, 
                homepage=None, private=False, has_wiki=True, 
                has_projects=True, has_issues=True) :
    """
    用来在当前用户或指定的 org 下创建 repo 的方法
    :param github: Github 实例
    :param name: string repo的名称
    :param org: string, 在哪个organization 下创建repo, 默认为 None
    :param description: string, repo的描述, 默认为None
    :param homepage: string, repo主页, 默认为None
    :param has_wiki: bool, 是否有wiki, 默认为True
    :param has_projects: bool, 是否有 projects, 默认为 True
    :prarm has_issues: bool, 是否有 issues, 默认为 True
    :return: CommonItem
    """
    result = CommonItem()
    result.success = False
    payload = {
        "name": name,
        "description": description,
        "homepage": homepage,
        "has_wiki": has_wiki,
        "has_projects": has_projects,
        "has_issues": has_issues
    }
    if org:
        response = github.repos.create_organization_repo(org, json=payload)
    else:
        response = github.repos.create_user_repo(json=payload)
    result.response = response
    if response.status_code == 201:
        result.success = True
    else:
        result.error = "create repo should be 201, but actually got {}".format(str(response.status_code))
    return result

3. 为什么封装的关键字中没有把全部的参数都写上?


4. 要不要在关键字内部写断言语句, 为什么?


5. 调用2中的关键字,进行测试和断言, 分以下集中情况:
   1. test 1: 在当前用户下创建一个repo，除了repo名字以外全部用默认值
   2. test 2: 在当前用户下创建一个repo，使用一些输入值
   3. test 3: 创建一个名为testme的repo，并且不包含projects，不包含issues，也不包含wiki
   4. test 4: 使用重复的repo名字再次创建，并且在断言语句中预期它会调用失败



16.130 接口测试框架设计3-TUGithubAPITest 的介绍
1. 开发关键字由什么决定? 具体到 TUGithubAPI/TUGithubAPITest 这个项目呢?
由需求决定. 在这个项目里是由 TUGithubAPITest这个项目内的具体case决定的

2. TUGithubAPITest 内部包含哪些模块? 每个模块的具体作用?
api_test 针对单个接口做的测试
scenario_test 针对多个接口组成的业务场景的测试
libraries 测试框架的库, 用户开发一些测试框架相关的库, 比如, 自定义测试报告模块, 测试数据
管理模块.


16.140 针对单个接口的测试
1. 怎样针对单个接口做测试?
使用脚本调用这个接口, 然后对这个接口的返回值做校验. 而且不限于校验返回值, 有时候还可以
进行进一步的校验, 比如校验数据库里的值, 有两种方式, 可以直接读取数据库, 也可以通过调用
其他现有接口来校验. 在写测试脚本时, 具体采用何种方式做校验取决于具体业务需求.

2. 什么是软断言?
当这个断言出错时, 当前的测试方法还会继续往下执行.

3. python 中的 assert是软断言吗? 怎样实现软断言?
assert 不是软断言, 也就是说当一个断言失败时测试方法就会立即退出, 不再执行后续的断言.
要么自己实现软断言, 要么就把测试方法级别拆小, 也就是同一个接口分好多个测试方法. 但这
并不意味着要拆到每个方法里只有一个断言, 需要自己把握好度.

4. assert 后面的第二个参数表示什么?
表示错误信息, 如果前面的断言失败, 则会输出这段错误信息

5. 针对列出一个github organization 中的 repo 这个接口做软断言测试, org名称TestUpCommunity
新建 test_01_repos.py
import pytest


def test_list_organization_repos_number(env):
    r = env.github.repos.list_organization_repos("TestUpCommunity")
    assert r.status_code == 200, "status_code should be 200 but actually={}".format(r)
    assert len(r.json()) == 2

def test_list_organization_repos_name(env):
    r = env.github.repos.list_organization_repos("TestUpCommunity")
    assert r.status_code == 200, "status_code should be 200 but actually={}".format(r)
    assert r.json()[0].get('name') == "TUGithubAPI"
    assert r.json()[0].get('name') == "TUGithubAPITest"


16.150 通过 fixture 做测试环境的切换
1. 添加 environment.py 文件并定义 Env 类， 这个类是用来做什么的？
2. 在 conftest.py 中定义 env 的 fixture
3. 为什么env设置为autouse但是测试用例里还是传了env？
4. 为什么 fixture 里的 print 语句不打印？
5. 如何修改环境变量？






16.180 针对场景的测试
1. 如何验证多个接口协同工作是否正常?
(如何进行业务场景测试/如何验证待测系统的多个组件之间的协同工作是否正常)
可以按照用户场景来测试. 在用户场景的接口测试中, 将会调用多个接口, 并观察多个接口
调用后用户的业务场景是否能成功, 以此来验证多个接口协同工作是否正常

2. 添加一个新的关键字用来创建分支
相关接口:
https://docs.github.com/en/rest/reference/git#get-a-reference
https://docs.github.com/en/rest/reference/git#create-a-reference

3. 在 scenario_test 下新建测试用例, 要求是: 利用在2中新建的关键字来在当前用户下
创建一个名称随机的新代码仓库, 然后在这个代码仓库下创建一个名为 test 的分支.


16.190 如何在实际项目中应用测试框架
1. 应用这个框架做实际项目的步骤?
1) 确认项目中所用的协议和数据封装方式
2) 确认鉴权方式
3) 确认接口文档, 并封装 Python 接口
4) 使用 Python 接口封装关键字
5) 在测试中灵活地使用关键字

2. 拿到一个新项目时，怎样确认它的接口是基于什么协议的？
一般来说，测试人员主要通过看接口文档以及和开发人员沟通的方式来了解这个项目的接口，还可以
用抓包工具自己抓包看。

3. 最常见的接口鉴权方式是什么？
最常见的接口鉴权方式是在请求头内包含特定的参数。

4. 请参照以上说明写一个rest客户端的鉴权部分


5. 接口文档一般包含哪些内容？


6. 将以上接口封装为 Example 类


7. 为什么每个接口的参数都是 **kwargs, 而没有按照接口文档中去定义?
因为这种写法在调用时可以直接传入 json 作为参数, 如果以后接口修改, 可以只在调用
的地方传入别的内容, 而无需修改这里的代码.

8. 构建调用 Example 类的方法, 并调用修改用户昵称的接口,并验证
from api.xxx.example import Example

class OnlineBusiness:
    def __init__(self, api_root_url, **kwargs):
        self.api_root_url = api_root_url
        self.example = Example(self.api_root_url, **kwargs)

if __name__ == '__main__':
    ob = OnlineBusiness("http://127.0.0.1")
    payload = {
        "phone": "13523332333",
        "pwd": 123
    }
    resp = ob.example.login(json=payload)
    assert resp.content['status'] == "0000"
    userId = resp.content['result']['userId']
    sessionId = resp.content['result']['sessionId']
    ob = OnlineBusiness("http://127.0.0.1", userId=userId, sessionId=sessionId)
    payload = {
        "nickName": "新昵称"
    }
    resp = ob.example.modify_user_nick(json=payload)
    assert resp.content['status'] == "0000"